---
title: C++为什么没有虚的成员函数模板
date: 2025-10-05 16:25:53
permalink: /pages/7f244c/
categories:
  - 所有文章
  - 技术
description: 面试题的一些思路
---

一个知乎问题，[c++模板成员函数为什么不能为虚函数？](https://www.zhihu.com/question/474773455)。

我觉得这可能是两个问题。

***

第一个，没有子类的成员函数模板实例化的过程：

```cpp
#include <memory>
#include <print>

struct Base {
    template <typename T>
    /* virtual */ void foo(T) {
        std::println("Base::foo");
    }
};

struct Derived : Base {
    template <typename T>
    void foo(T) {
        std::println("Derived::foo");
    }
};

int main() {
    std::unique_ptr<Base> d = std::make_unique<Derived>();
    d->foo(114514);  // Base::foo，怎么才能输出 Derived::foo？
}
```

想要上面代码输出 Derived::foo，谁来了都不行，除非运行时调编译器给你实例化一个了。

***

第二个，有实例化的过程，假设有个神奇的宏 INTERFACE：

```cpp
#include <memory>
#include <print>

struct Base {
    template <typename T>
    /* virtual */ void foo(T) {
        std::println("Base::foo");
    }
};

struct Derived : Base {
    template <typename T>
    void foo(T) {
        std::println("Derived::foo");
    }
};

INTERFACE(Base2, Base, FUNC(foo, int));

int main() {
    std::unique_ptr<Base2> d = std::make_unique<Derived>();
    d->foo(114514);
}
```

其他答主已经回答了为什么虚表 (vtable) 做不到。于是很自然地想到，跳出虚表会怎么样？于是我用微软的 proxy 库试了一下，是可以的：<https://godbolt.org/z/b7q1z4WPW>

所以根本问题是，C++ 没有提供一个语法表达这个神奇的宏 INTERFACE。
