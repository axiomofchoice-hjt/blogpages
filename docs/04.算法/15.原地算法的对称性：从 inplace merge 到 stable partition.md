---
title: 原地算法的对称性：从 inplace merge 到 stable partition
date: 2026-02-07 22:34:30
permalink: /pages/1a8ff1/
categories:
  - 算法
description: 围绕“原地算法”的结构对称性，从 inplace merge 与 stable partition 两个经典 O(n log n) 算法切入，讨论 rotate 操作在分治中的核心作用，以及快速排序与归并排序在原地稳定算法里的镜像关系。
---

> 围绕“原地算法”的结构对称性，从 inplace merge 与 stable partition 两个经典 O(n log n) 算法切入，讨论 rotate 操作在分治中的核心作用，以及快速排序与归并排序在原地稳定算法里的镜像关系。

## 1. 从双指针 merge 开始讲起

说到合并 (merge) 两个有序数组，最简单强大的做法就是双指针。两个指针指向两个数组的开始位置，不断把较小元素放到 buffer 数组，对应指针向后移动。最后把 buffer 里的元素移动回原数组。

这个过程如下图所示：

![merge_to](/animation/1a8ff1-0.webp)

这个算法在 C++ [std::merge](https://en.cppreference.com/w/cpp/algorithm/merge.html) 里亦有记载。

***

但是这个算法需要一个 $O(n)$ 的额外空间复杂度（就是 buffer 数组），有没有办法可以原地进行呢？有的兄弟，原地算法有很多小巧思，这篇文章也算是个开头。

“原地”其实有两种含义，一是算法的结果直接写回原数组，比如 C++ `std::inplace_merge` 就是这个含义；二是 $O(1)$ 的额外空间复杂度，有时会允许 $O(\log n)$ 的递归栈，这篇文章的“原地”都是这个含义。

## 2. rotate 区间旋转算法

原地算法基本绕不开 rotate（区间旋转），把两个相邻区间 `[A B]` 原地变成 `[B A]`，保持区间内部顺序不变。这个方法不唯一，最经典的做法是三次翻转法（或手摇算法）：先分别翻转区间 A 和区间 B，再整体翻转整个区间 `[A B]`，就能得到 `[B A]`。

这个过程如下图所示：

![rotate](/animation/1a8ff1-1.webp)

这个算法在 C++ [std::rotate](https://en.cppreference.com/w/cpp/algorithm/rotate.html) 里亦有记载。

## 3. inplace merge 的分治算法

（我们约定 merge 的接口是，输入一个长度为 n 的数组 arr 和一个位置 pos，`arr[0] ... arr[pos - 1]` 属于第一个有序数组 A，`arr[pos] ... arr[n - 1]` 属于有序数组 B，merge 的结果是合并两个有序数组为 `arr[0] ... arr[n]`）

怎么做呢？答案是简化的快速排序。

我们选数组中的一个数 pivot = `arr[x]`（马上讲怎么选这个数）。由于两个数组一开始是有序的，每个数组天然划分成小于 pivot、大于等于 pivot 两个区间，一共 4 个区间。只要把中间两个区间旋转一下，这时候变成了左边两个有序数组，右边也是两个有序数组，递归即可。

那么怎么选择 pivot 呢？可以选择中位数，我们模拟双指针的方法可以把中位数求出来，但是这样会有找中位数的开销。所以更合理的做法是取两个有序数组里较长的那个的中间值，另一个数组就用二分查找来划分。这样最坏情况也能 1:3 的比例划分数组，整个算法时间复杂度 $O(n \log n)$，读者自证不难。因为需要调用栈，额外空间复杂度 $O(\log n)$。

***

我们来看一个例子，初始数组 `[2, 5, 6, 7, 12, 19], [1, 4, 6, 7, 8, 11, 13, 14, 14, 18]`：

![img](/img/1a8ff1-0.drawio.png)

***

这个算法在 C++ [std::inplace_merge](https://en.cppreference.com/w/cpp/algorithm/inplace_merge.html) 里亦有记载（如果空间不够的话）。

我们顺便浏览一下 libstdc++ 的实现。

1. [std::inplace_merge](https://github.com/gcc-mirror/gcc/blob/releases/gcc-15.2.0/libstdc%2B%2B-v3/include/bits/stl_algo.h#L2594) 会直接调用 std::__inplace_merge。
2. [std::__inplace_merge](https://github.com/gcc-mirror/gcc/blob/releases/gcc-15.2.0/libstdc%2B%2B-v3/include/bits/stl_algo.h#L2487) 如果申请 buffer 失败，调用 std::__merge_without_buffer。
3. [std::__merge_without_buffer](https://github.com/gcc-mirror/gcc/blob/releases/gcc-15.2.0/libstdc%2B%2B-v3/include/bits/stl_algo.h#L2437) 这里就是上面算法的实现了。

## 4. 变成严格的原地算法

严格的原地算法，也就是额外空间复杂度 $O(1)$，怎么做呢？需要略微修改一下。

上面算法的 $O(\log n)$ 空间是调用栈造成的。调用栈的作用，是为了恢复调用方的状态，那么什么情况下不用栈也能恢复状态呢？对于区间范围，我们需要把数组划分到确定的位置，最简单的就是 2 的整数幂位置，这样通过简单的二进制运算就能恢复了。对于初始两个有序数组的分界线，这个可以直接遍历一遍找到。

具体算法就是，先确定大于等于数组大小的 2 的整数幂（C++ 的 `std::bit_ceil`）为 block。把整个数组按大小为 block 分块，每个 block 块划分为 `block / 2` 和剩下部分，然后 `block /= 2` 重复分块的步骤，直到 block 变成 1。

伪代码如下：

```cpp
void inplace_merge(int *a, size_t n) {
    for (size_t block = std::bit_ceil(n); block > 1; block /= 2) {
        for (size_t i = 0; i < n; i += block) {
            if (i + block / 2 < n) {
                /* 划分为 [i, i + block / 2 - 1] [i + block / 2, i + std::min(block, n) - 1] */
            }
        }
    }
}
```

于是问题就剩下如何划分了。由于一开始数组是两个有序数组组成，遍历一遍可以找到两个有序数组的分界线。通过双指针找第 `block / 2` 小的数，确定了这些就是一个 rotate 完成划分了。

## 5. stable partition 的分治算法

划分 (partition) 是快速排序里的一个步骤，就是给定一个数字 pivot，把数组里小于 pivot 的放前面，大于等于 pivot 的放后面。这里再加个稳定的要求，就是保持小于 pivot 的数字之间顺序不变，大于等于同理。

怎么做呢？答案是简化的归并排序。

我们取中间位置，左右两边分别递归求解，这样左右分别得到小于 pivot、大于等于 pivot 的两个区间，一共 4 个区间。这时候只要把中间两个区间旋转一下，就结束了。旋转 $O(n)$ 就行了，整个算法时间复杂度 $O(n \log n)$，读者自证不难。

这个算法在 C++ [std::stable_partition](https://en.cppreference.com/w/cpp/algorithm/stable_partition.html) 里亦有记载（如果空间不够的话）。

## 6. 从 merge 到 partition

有没有发现，我讲 stable partition 算法时好像在倒着讲述 inplace merge 算法。

merge 和 partition 仿佛就是关于时间对称的两个算法。它们甚至你中有我，我中有你：inplace merge 是简化的快速排序，单个步骤是 partition；stable partition 是简化的归并排序，单个步骤是 merge。

非常神奇。

***

想必有人不满意 $O(n\log n)$ 的时间复杂度吧。其实存在 $O(n)$ 的原地稳定 merge 算法，这个算法也能很容易实现 $O(n \log n)$ 原地稳定排序，这边就挖个坑。
